#!/usr/bin/env python

import sys
from argparse import ArgumentParser
from collections import defaultdict
from itertools import islice

__author__ = "Xiongbin Kang, Luo Xiao"


usage = """%prog <min_ovlp_len> <min_iden> <mini overhang>

 This program is used to filter read overlaps(i.e.,duplicate or internal overlaps) in paf file that were generated by mininmap2
 
"""

def main():
    parser = ArgumentParser(description = usage)
    parser.add_argument('-len', dest = 'min_ovlp_len', default = 60, type = int)
    parser.add_argument('-iden', dest = 'min_iden', default = 0.8, type = float)
    parser.add_argument('-oh', dest = 'min_o', default = 0, type = int)
    parser.add_argument('-sfo', dest = 'sfo', action='store_true')
    args = parser.parse_args()

    if not (args.min_ovlp_len and args.min_iden):
        print("Specify min over length and min identical.")
        parser.print_help()
        sys.exit()

    
    if not sys.stdin.isatty():
      while True:
        ovlp_item = list(islice(sys.stdin, 1000))
        if not ovlp_item:
            break
        ovlp_str = ''.join(ovlp_item).strip()

        d = defaultdict(list)
        for line in ovlp_str.strip().split('\n'):

            [qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length] = line.split('\t')[:11]
            
            (qlen, qstart, qend, slen, sstart, send, matchcount, length) = map(int, [qlen, qstart, qend, slen, sstart, send, matchcount, length])
            
            mlen=(qlen+slen)/2
                        
            if (length < args.min_ovlp_len) or (matchcount / length < args.min_iden) or (qseqid == sseqid):
                continue
            
            key1 = ':'.join(sorted([qseqid, sseqid]))
            if key1 in d:
                continue    
            d[key1] = 1
            
            # filter overlap with overhang parameter
            if qori == '-':
                sstart2 = slen - send  # end in original seq
                send2 = slen - sstart  # start in original seq
            
                overhang = min(qstart, sstart2) + min(qlen - qend, slen - send2)
                maplen = max(qend - qstart, send2 - sstart2)

            else:
                # from algorithm 5 in minimap paper
                overhang = min(qstart, sstart) + min(qlen - qend, slen - send)
                maplen = max(qend - qstart, send - sstart)

            if overhang > min(args.min_o, maplen * 0.8):
                # internal match
                continue
            
            # tranfer the format of minimap2 to sfo
            if args.sfo:
                line = minimap22sfo(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length)
                print(line)
            else:
                line2 ="\t".join([qseqid, sseqid, str(0.1*(length/mlen)+0.9*(matchcount/length))] )
                print(line2)
  
    
def minimap22sfo(qseqid, qlen, qstart, qend, qori, sseqid, slen, sstart, send, matchcount, length):
            ori = 'N' if qori == '+' else 'I'
            
            if ori == 'N':
                OHA = qstart - sstart
                OHB = slen - sstart - (qlen - qstart)
            else:
                OHA = qstart - (slen - send)
                OHB = send - (qlen - qstart)
                
            if OHA >= 0:
                OLA = min(qlen - OHA, slen)
            else:
                OLA = min(slen + OHA, qlen)
                
            OLB = OLA
            mismatch = length - matchcount
            
            sfo_line = '\t'.join([qseqid, sseqid, ori, str(OHA), str(OHB), str(OLA), str(OLB), str(mismatch)])
            return sfo_line
            

if __name__ == '__main__':
        sys.exit(main())
